// Code generated by ndn tlv codegen DO NOT EDIT.
package tlv

import (
	"encoding/binary"
	"strings"

	enc "github.com/named-data/ndnd/std/encoding"
)

type MessageEncoder struct {
	Length uint

	YjsDelta_encoder YjsDeltaEncoder
}

type MessageParsingContext struct {
	YjsDelta_context YjsDeltaParsingContext
}

func (encoder *MessageEncoder) Init(value *Message) {
	if value.YjsDelta != nil {
		encoder.YjsDelta_encoder.Init(value.YjsDelta)
	}

	l := uint(0)
	if value.YjsDelta != nil {
		l += 1
		l += uint(enc.TLNum(encoder.YjsDelta_encoder.Length).EncodingLength())
		l += encoder.YjsDelta_encoder.Length
	}
	encoder.Length = l

}

func (context *MessageParsingContext) Init() {
	context.YjsDelta_context.Init()
}

func (encoder *MessageEncoder) EncodeInto(value *Message, buf []byte) {

	pos := uint(0)

	if value.YjsDelta != nil {
		buf[pos] = byte(200)
		pos += 1
		pos += uint(enc.TLNum(encoder.YjsDelta_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.YjsDelta_encoder.Length > 0 {
			encoder.YjsDelta_encoder.EncodeInto(value.YjsDelta, buf[pos:])
			pos += encoder.YjsDelta_encoder.Length
		}
	}
}

func (encoder *MessageEncoder) Encode(value *Message) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *MessageParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Message, error) {

	var handled_YjsDelta bool = false

	progress := -1
	_ = progress

	value := &Message{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 200:
				if true {
					handled = true
					handled_YjsDelta = true
					value.YjsDelta, err = context.YjsDelta_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_YjsDelta && err == nil {
		value.YjsDelta = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *Message) Encode() enc.Wire {
	encoder := MessageEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *Message) Bytes() []byte {
	return value.Encode().Join()
}

func ParseMessage(reader enc.WireView, ignoreCritical bool) (*Message, error) {
	context := MessageParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type YjsDeltaEncoder struct {
	Length uint
}

type YjsDeltaParsingContext struct {
}

func (encoder *YjsDeltaEncoder) Init(value *YjsDelta) {

	l := uint(0)
	l += 3
	l += uint(enc.TLNum(len(value.UUID)).EncodingLength())
	l += uint(len(value.UUID))
	if value.Binary != nil {
		l += 3
		l += uint(enc.TLNum(len(value.Binary)).EncodingLength())
		l += uint(len(value.Binary))
	}
	encoder.Length = l

}

func (context *YjsDeltaParsingContext) Init() {

}

func (encoder *YjsDeltaEncoder) EncodeInto(value *YjsDelta, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(1144))
	pos += 3
	pos += uint(enc.TLNum(len(value.UUID)).EncodeInto(buf[pos:]))
	copy(buf[pos:], value.UUID)
	pos += uint(len(value.UUID))
	if value.Binary != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(1200))
		pos += 3
		pos += uint(enc.TLNum(len(value.Binary)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Binary)
		pos += uint(len(value.Binary))
	}
}

func (encoder *YjsDeltaEncoder) Encode(value *YjsDelta) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *YjsDeltaParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*YjsDelta, error) {

	var handled_UUID bool = false
	var handled_Binary bool = false

	progress := -1
	_ = progress

	value := &YjsDelta{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1144:
				if true {
					handled = true
					handled_UUID = true
					{
						var builder strings.Builder
						_, err = reader.CopyN(&builder, int(l))
						if err == nil {
							value.UUID = builder.String()
						}
					}
				}
			case 1200:
				if true {
					handled = true
					handled_Binary = true
					value.Binary = make([]byte, l)
					_, err = reader.ReadFull(value.Binary)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_UUID && err == nil {
		err = enc.ErrSkipRequired{Name: "UUID", TypeNum: 1144}
	}
	if !handled_Binary && err == nil {
		value.Binary = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *YjsDelta) Encode() enc.Wire {
	encoder := YjsDeltaEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *YjsDelta) Bytes() []byte {
	return value.Encode().Join()
}

func ParseYjsDelta(reader enc.WireView, ignoreCritical bool) (*YjsDelta, error) {
	context := YjsDeltaParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
