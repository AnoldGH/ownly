// Code generated by ndn tlv codegen DO NOT EDIT.
package tlv

import (
	"encoding/binary"

	enc "github.com/named-data/ndnd/std/encoding"
)

type MessageEncoder struct {
	length uint

	Chat_encoder ChatMessageEncoder
}

type MessageParsingContext struct {
	Chat_context ChatMessageParsingContext
}

func (encoder *MessageEncoder) Init(value *Message) {
	if value.Chat != nil {
		encoder.Chat_encoder.Init(value.Chat)
	}

	l := uint(0)
	if value.Chat != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Chat_encoder.length).EncodingLength())
		l += encoder.Chat_encoder.length
	}
	encoder.length = l

}

func (context *MessageParsingContext) Init() {
	context.Chat_context.Init()
}

func (encoder *MessageEncoder) EncodeInto(value *Message, buf []byte) {

	pos := uint(0)

	if value.Chat != nil {
		buf[pos] = byte(200)
		pos += 1
		pos += uint(enc.TLNum(encoder.Chat_encoder.length).EncodeInto(buf[pos:]))
		if encoder.Chat_encoder.length > 0 {
			encoder.Chat_encoder.EncodeInto(value.Chat, buf[pos:])
			pos += encoder.Chat_encoder.length
		}
	}
}

func (encoder *MessageEncoder) Encode(value *Message) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *MessageParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*Message, error) {

	var handled_Chat bool = false

	progress := -1
	_ = progress

	value := &Message{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 200:
				if true {
					handled = true
					handled_Chat = true
					value.Chat, err = context.Chat_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Chat && err == nil {
		value.Chat = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *Message) Encode() enc.Wire {
	encoder := MessageEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *Message) Bytes() []byte {
	return value.Encode().Join()
}

func ParseMessage(reader enc.WireView, ignoreCritical bool) (*Message, error) {
	context := MessageParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ChatMessageEncoder struct {
	length uint
}

type ChatMessageParsingContext struct {
}

func (encoder *ChatMessageEncoder) Init(value *ChatMessage) {

	l := uint(0)
	if value.Message != nil {
		l += 3
		l += uint(enc.TLNum(len(value.Message)).EncodingLength())
		l += uint(len(value.Message))
	}
	encoder.length = l

}

func (context *ChatMessageParsingContext) Init() {

}

func (encoder *ChatMessageEncoder) EncodeInto(value *ChatMessage, buf []byte) {

	pos := uint(0)

	if value.Message != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(1200))
		pos += 3
		pos += uint(enc.TLNum(len(value.Message)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Message)
		pos += uint(len(value.Message))
	}
}

func (encoder *ChatMessageEncoder) Encode(value *ChatMessage) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ChatMessageParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*ChatMessage, error) {

	var handled_Message bool = false

	progress := -1
	_ = progress

	value := &ChatMessage{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 1200:
				if true {
					handled = true
					handled_Message = true
					value.Message = make([]byte, l)
					_, err = reader.ReadFull(value.Message)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Message && err == nil {
		value.Message = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ChatMessage) Encode() enc.Wire {
	encoder := ChatMessageEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ChatMessage) Bytes() []byte {
	return value.Encode().Join()
}

func ParseChatMessage(reader enc.WireView, ignoreCritical bool) (*ChatMessage, error) {
	context := ChatMessageParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
